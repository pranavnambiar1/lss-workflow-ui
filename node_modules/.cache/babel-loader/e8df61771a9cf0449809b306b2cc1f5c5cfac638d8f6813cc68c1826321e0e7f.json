{"ast":null,"code":"var _jsxFileName = \"/Users/pranav.nambiar/Documents/lss-workflow-ui/src/components/WorkflowBuilder.tsx\",\n  _s = $RefreshSig$();\nimport React, { useCallback, useState, useRef } from 'react';\nimport { Box, Typography, Chip, Button } from '@mui/material';\nimport ArrowBackIcon from '@mui/icons-material/ArrowBack';\nimport ReactFlow, { addEdge, useNodesState, useEdgesState, Controls, Background, BackgroundVariant } from 'reactflow';\nimport 'reactflow/dist/style.css';\nimport ApiSidebar from './ApiSidebar';\nimport JobsPanel from './JobsPanel';\nimport ResponseSelectorModal from './ResponseSelectorModal';\nimport TaskNode from './TaskNode';\nimport ApiNode from './ApiNode';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WorkflowBuilder = ({\n  workflowState,\n  setWorkflowState\n}) => {\n  _s();\n  const [nodes, setNodes, onNodesChange] = useNodesState([]);\n  const [edges, setEdges, onEdgesChange] = useEdgesState([]);\n  const [isResponseModalOpen, setIsResponseModalOpen] = useState(false);\n  const [pendingConnection, setPendingConnection] = useState(null);\n  const [selectedTask, setSelectedTask] = useState(null);\n\n  // Audio references for sound effects\n  const clickSoundRef = useRef(null);\n  const dropSoundRef = useRef(null);\n  const connectSoundRef = useRef(null);\n\n  // Initialize audio elements\n  React.useEffect(() => {\n    clickSoundRef.current = new Audio('/sounds/click.mp3');\n    dropSoundRef.current = new Audio('/sounds/drop.mp3');\n    connectSoundRef.current = new Audio('/sounds/connect.mp3');\n  }, []);\n\n  // Handle task selection\n  const handleTaskSelect = useCallback(task => {\n    // Play click sound\n    if (clickSoundRef.current) {\n      clickSoundRef.current.play().catch(e => console.log('Audio play failed:', e));\n    }\n    setSelectedTask(task);\n\n    // Create a new task node in the workflow\n    const taskNode = {\n      id: `task-${task.id}-${Date.now()}`,\n      type: 'task',\n      // Special node type for tasks\n      data: {\n        label: task.name,\n        task: task,\n        isTask: true // Flag to identify task nodes\n      },\n      position: {\n        x: 100,\n        y: 100 + nodes.length * 10 % 300\n      } // Position the task node\n    };\n    setNodes(nds => [...nds, taskNode]);\n  }, [nodes]);\n\n  // Handle API node drop\n  const handleApiDrop = useCallback(apiNodeData => {\n    // Play drop sound\n    if (dropSoundRef.current) {\n      dropSoundRef.current.play().catch(e => console.log('Audio play failed:', e));\n    }\n    try {\n      var _parsedData$api, _parsedData$data, _parsedData$api2, _parsedData$data2, _parsedData$data2$api, _parsedData$api3, _parsedData$data3, _parsedData$data3$api;\n      console.log('Raw API drop data:', apiNodeData);\n\n      // Parse the API data if it's a string (from drag and drop)\n      let parsedData = typeof apiNodeData === 'string' ? JSON.parse(apiNodeData) : apiNodeData;\n      console.log('Parsed API data:', parsedData);\n\n      // If the parsed data has a data property (from ReactFlow drag/drop), extract it\n      if (parsedData.data) {\n        console.log('Found nested data structure, extracting...');\n        // Keep the original parsed data for reference\n        const originalData = parsedData;\n\n        // If there's an api object in the data, prioritize that\n        if (parsedData.data.api) {\n          console.log('Found API object in data.api');\n          // Merge the data structure to ensure we have all properties\n          parsedData = {\n            ...parsedData,\n            ...parsedData.data,\n            api: parsedData.data.api\n          };\n        } else {\n          // Otherwise just merge with the data object\n          parsedData = {\n            ...parsedData,\n            ...parsedData.data\n          };\n        }\n        console.log('Restructured data:', parsedData);\n      }\n\n      // Extract API name with extensive fallbacks\n      let apiName = '';\n      if (parsedData.api && parsedData.api.name) {\n        apiName = parsedData.api.name;\n      } else if (parsedData.name) {\n        apiName = parsedData.name;\n      } else if (parsedData.label) {\n        apiName = parsedData.label;\n      } else if (parsedData.data && parsedData.data.name) {\n        apiName = parsedData.data.name;\n      } else if (parsedData.data && parsedData.data.label) {\n        apiName = parsedData.data.label;\n      } else {\n        apiName = 'API Node';\n      }\n      console.log('Extracted API name:', apiName);\n\n      // Extract description with fallbacks\n      const apiDescription = ((_parsedData$api = parsedData.api) === null || _parsedData$api === void 0 ? void 0 : _parsedData$api.description) || parsedData.description || ((_parsedData$data = parsedData.data) === null || _parsedData$data === void 0 ? void 0 : _parsedData$data.description) || '';\n\n      // Get responses and category with fallbacks\n      const responses = ((_parsedData$api2 = parsedData.api) === null || _parsedData$api2 === void 0 ? void 0 : _parsedData$api2.responses) || parsedData.responses || ((_parsedData$data2 = parsedData.data) === null || _parsedData$data2 === void 0 ? void 0 : (_parsedData$data2$api = _parsedData$data2.api) === null || _parsedData$data2$api === void 0 ? void 0 : _parsedData$data2$api.responses) || [];\n      const category = ((_parsedData$api3 = parsedData.api) === null || _parsedData$api3 === void 0 ? void 0 : _parsedData$api3.category) || parsedData.category || ((_parsedData$data3 = parsedData.data) === null || _parsedData$data3 === void 0 ? void 0 : (_parsedData$data3$api = _parsedData$data3.api) === null || _parsedData$data3$api === void 0 ? void 0 : _parsedData$data3$api.category) || '';\n\n      // Create a new API node with the provided data\n      const apiNode = {\n        id: `api-${Date.now()}`,\n        type: 'api',\n        // Explicitly set the type to 'api'\n        position: {\n          x: 400,\n          y: 100 + nodes.length * 10 % 300\n        },\n        // Position the API node\n        data: {\n          label: apiName,\n          // Set label for display\n          name: apiName,\n          // Ensure name is set\n          description: apiDescription,\n          api: {\n            name: apiName,\n            // Ensure API name is set\n            description: apiDescription,\n            responses: responses,\n            category: category\n          },\n          isApi: true // Additional flag to identify API nodes\n        }\n      };\n      console.log('Created API node:', apiNode);\n      setNodes(nds => [...nds, apiNode]);\n    } catch (error) {\n      console.error('Error handling API drop:', error);\n    }\n  }, [nodes]);\n\n  // Custom connection validation\n  const isValidConnection = useCallback(connection => {\n    // Get source and target nodes\n    const sourceNode = nodes.find(node => node.id === connection.source);\n    const targetNode = nodes.find(node => node.id === connection.target);\n\n    // Allow connections from task nodes to API nodes\n    if ((sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.type) === 'task' && (targetNode === null || targetNode === void 0 ? void 0 : targetNode.type) === 'api') {\n      // Play connect sound on valid connection attempt\n      if (connectSoundRef.current) {\n        connectSoundRef.current.play().catch(e => console.log('Audio play failed:', e));\n      }\n      return true;\n    }\n\n    // Allow connections between API nodes (for sequential ordering)\n    if ((sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.type) === 'api' && (targetNode === null || targetNode === void 0 ? void 0 : targetNode.type) === 'api') {\n      // Check if connecting from bottom to top (proper direction)\n      if (connection.sourceHandle === 'bottom' && connection.targetHandle === 'top') {\n        // Play connect sound on valid connection attempt\n        if (connectSoundRef.current) {\n          connectSoundRef.current.play().catch(e => console.log('Audio play failed:', e));\n        }\n        return true;\n      }\n    }\n    return false;\n  }, [nodes]);\n  const onConnect = useCallback(params => {\n    // Validate connection\n    if (isValidConnection(params)) {\n      // Get source and target nodes\n      const sourceNode = nodes.find(node => node.id === params.source);\n      const targetNode = nodes.find(node => node.id === params.target);\n\n      // Only show response selector for API-to-API connections\n      if ((sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.type) === 'api' && (targetNode === null || targetNode === void 0 ? void 0 : targetNode.type) === 'api') {\n        // Open response selector modal when connecting APIs\n        setPendingConnection(params);\n        setIsResponseModalOpen(true);\n      } else {\n        // For task-to-API connections, create the edge directly\n        setEdges(eds => addEdge({\n          ...params,\n          animated: true\n        }, eds));\n      }\n    }\n  }, [isValidConnection, nodes, setEdges]);\n\n  // Define node types for ReactFlow\n  // FIXED: Ensure node types are properly defined and consistently used\n  const nodeTypes = React.useMemo(() => {\n    console.log('Defining node types');\n    return {\n      task: TaskNode,\n      api: ApiNode\n    };\n  }, []);\n\n  // Traverse workflow and export as JSON\n  const traverseWorkflow = useCallback(() => {\n    // CRITICAL DEBUG: Dump all nodes to console for inspection\n    console.log('%c CRITICAL DEBUGGING: All Nodes in Workflow', 'background: #ff0000; color: white; font-size: 16px');\n    console.log('Total nodes count:', nodes.length);\n    nodes.forEach((node, index) => {\n      console.log(`Node ${index + 1}:`, {\n        id: node.id,\n        type: node.type,\n        data: node.data,\n        position: node.position,\n        // Convert the node to string to see all properties\n        fullObject: JSON.stringify(node)\n      });\n    });\n\n    // CRITICAL DEBUG: Dump all edges to console\n    console.log('%c CRITICAL DEBUGGING: All Edges in Workflow', 'background: #ff0000; color: white; font-size: 16px');\n    console.log('Total edges count:', edges.length);\n    edges.forEach((edge, index) => {\n      console.log(`Edge ${index + 1}:`, {\n        id: edge.id,\n        source: edge.source,\n        target: edge.target,\n        data: edge.data,\n        // Convert the edge to string to see all properties\n        fullObject: JSON.stringify(edge)\n      });\n    });\n\n    // Create a dot element for animation\n    const dotElement = document.createElement('div');\n    dotElement.style.position = 'absolute';\n    dotElement.style.width = '15px';\n    dotElement.style.height = '15px';\n    dotElement.style.backgroundColor = '#ff5722';\n    dotElement.style.borderRadius = '50%';\n    dotElement.style.zIndex = '1000';\n    dotElement.style.transition = 'all 0.5s ease';\n\n    // Add the dot to the ReactFlow container\n    const reactFlowContainer = document.querySelector('.react-flow');\n    if (reactFlowContainer) {\n      reactFlowContainer.appendChild(dotElement);\n\n      // CRITICAL FIX: Force all nodes to have proper types for detection\n      // This ensures that any node that looks like an API node is treated as one\n      nodes.forEach(node => {\n        var _node$id, _node$data, _node$data$label, _node$data2, _node$data2$label, _node$data3, _node$data3$name, _node$data4, _node$data4$name, _node$data5, _node$data6, _node$data7;\n        // Check if this node might be an API node based on various heuristics\n        const mightBeApiNode = ((_node$id = node.id) === null || _node$id === void 0 ? void 0 : _node$id.includes('api')) || ((_node$data = node.data) === null || _node$data === void 0 ? void 0 : (_node$data$label = _node$data.label) === null || _node$data$label === void 0 ? void 0 : _node$data$label.includes('api')) || ((_node$data2 = node.data) === null || _node$data2 === void 0 ? void 0 : (_node$data2$label = _node$data2.label) === null || _node$data2$label === void 0 ? void 0 : _node$data2$label.includes('API')) || ((_node$data3 = node.data) === null || _node$data3 === void 0 ? void 0 : (_node$data3$name = _node$data3.name) === null || _node$data3$name === void 0 ? void 0 : _node$data3$name.includes('api')) || ((_node$data4 = node.data) === null || _node$data4 === void 0 ? void 0 : (_node$data4$name = _node$data4.name) === null || _node$data4$name === void 0 ? void 0 : _node$data4$name.includes('API')) || ((_node$data5 = node.data) === null || _node$data5 === void 0 ? void 0 : _node$data5.api) || ((_node$data6 = node.data) === null || _node$data6 === void 0 ? void 0 : _node$data6.isApi) ||\n        // If it's not explicitly a task node, treat it as an API node\n        node.type !== 'task' && !((_node$data7 = node.data) !== null && _node$data7 !== void 0 && _node$data7.isTask);\n        if (mightBeApiNode) {\n          console.log(`%c CRITICAL FIX: Forcing node ${node.id} to be an API node`, 'background: #00ff00; color: black');\n          // Directly modify the node to ensure it's detected as an API node\n          node.type = 'api';\n          if (!node.data) node.data = {};\n          node.data.isApi = true;\n          if (!node.data.api) {\n            node.data.api = {\n              name: node.data.label || node.data.name || `API Node ${node.id}`,\n              responses: []\n            };\n          }\n        }\n      });\n\n      // Get all task nodes\n      const taskNodes = nodes.filter(node => node.type === 'task');\n      console.log('Task nodes after fix:', taskNodes.length);\n\n      // Get all API nodes\n      const apiNodes = nodes.filter(node => node.type === 'api');\n      console.log('API nodes after fix:', apiNodes.length);\n\n      // Get all edges\n      const workflowEdges = edges;\n\n      // CRITICAL DEBUG: Check if we have API nodes now\n      if (apiNodes.length === 0) {\n        console.error('%c CRITICAL ERROR: Still no API nodes detected after fixes!', 'background: #ff0000; color: white; font-size: 20px');\n        // Emergency fallback: Treat all non-task nodes as API nodes\n        const emergencyApiNodes = nodes.filter(node => node.type !== 'task');\n        console.log('Emergency API nodes:', emergencyApiNodes.length);\n        if (emergencyApiNodes.length > 0) {\n          console.log('Using emergency API nodes for export');\n          // Skip animation and go straight to export\n          exportWorkflowAsJson();\n          return;\n        }\n      }\n\n      // Start animation from the first task node\n      if (taskNodes.length > 0) {\n        const startNode = taskNodes[0];\n        const nodeElement = document.querySelector(`[data-id=\"${startNode.id}\"]`);\n        if (nodeElement) {\n          const rect = nodeElement.getBoundingClientRect();\n          const containerRect = reactFlowContainer.getBoundingClientRect();\n\n          // Position the dot at the start node\n          dotElement.style.left = `${rect.left - containerRect.left + rect.width / 2 - 7.5}px`;\n          dotElement.style.top = `${rect.top - containerRect.top + rect.height / 2 - 7.5}px`;\n\n          // Start the animation\n          setTimeout(() => animateWorkflow(dotElement, taskNodes, apiNodes, workflowEdges, 0), 500);\n        } else {\n          // If we can't find the element, just export\n          console.log('Could not find start node element, skipping animation');\n          exportWorkflowAsJson();\n        }\n      } else {\n        // If there are no task nodes, just export\n        console.log('No task nodes found, skipping animation');\n        exportWorkflowAsJson();\n      }\n    } else {\n      console.error('Could not find ReactFlow container');\n      // Try to export anyway\n      exportWorkflowAsJson();\n    }\n  }, [nodes, edges]);\n\n  // Animate the workflow traversal\n  const animateWorkflow = useCallback((dotElement, taskNodes, apiNodes, workflowEdges, currentIndex) => {\n    // If we've gone through all nodes, export the JSON\n    if (currentIndex >= taskNodes.length + apiNodes.length) {\n      // Remove the dot element\n      dotElement.remove();\n\n      // Export the workflow as JSON\n      exportWorkflowAsJson();\n      return;\n    }\n\n    // Determine the next node to animate to\n    let nextNode;\n    if (currentIndex < taskNodes.length) {\n      // Animate to the next task node\n      nextNode = taskNodes[currentIndex];\n    } else {\n      // Animate to the API nodes\n      nextNode = apiNodes[currentIndex - taskNodes.length];\n    }\n\n    // Find the element for the next node\n    const nodeElement = document.querySelector(`[data-id=\"${nextNode.id}\"]`);\n    if (nodeElement) {\n      const rect = nodeElement.getBoundingClientRect();\n      const reactFlowElement = document.querySelector('.react-flow');\n      if (!reactFlowElement) return;\n      const containerRect = reactFlowElement.getBoundingClientRect();\n\n      // Animate the dot to the next node\n      dotElement.style.left = `${rect.left - containerRect.left + rect.width / 2 - 7.5}px`;\n      dotElement.style.top = `${rect.top - containerRect.top + rect.height / 2 - 7.5}px`;\n\n      // Highlight the node\n      nodeElement.classList.add('highlighted');\n      setTimeout(() => nodeElement.classList.remove('highlighted'), 500);\n\n      // Continue to the next node after a delay\n      setTimeout(() => animateWorkflow(dotElement, taskNodes, apiNodes, workflowEdges, currentIndex + 1), 800);\n    } else {\n      // Skip to the next node if this one isn't found\n      setTimeout(() => animateWorkflow(dotElement, taskNodes, apiNodes, workflowEdges, currentIndex + 1), 100);\n    }\n  }, []);\n\n  // Export the workflow as JSON\n  const exportWorkflowAsJson = useCallback(() => {\n    console.log('%c ULTRA-CRITICAL FUNCTION: exportWorkflowAsJson', 'background: #ff0000; color: white; font-size: 24px');\n    console.log('All nodes:', nodes);\n    console.log('All edges:', edges);\n\n    // ULTRA-AGGRESSIVE FIX: Create synthetic API nodes from the visible elements if needed\n    // This approach bypasses all ReactFlow internal state issues\n\n    // Step 1: Try to get nodes from DOM if ReactFlow state is problematic\n    const domNodes = document.querySelectorAll('.react-flow__node');\n    console.log(`%c DOM nodes found: ${domNodes.length}`, 'background: #ff00ff; color: white; font-size: 16px');\n\n    // Step 2: Create a backup collection of nodes based on what's visible in the DOM\n    const backupNodes = [];\n    domNodes.forEach((domNode, index) => {\n      const nodeId = domNode.getAttribute('data-id') || `synthetic-node-${index}`;\n      const nodeType = domNode.classList.contains('task') ? 'task' : 'api';\n      const labelElement = domNode.querySelector('.node-label') || domNode.querySelector('.label') || domNode;\n      const label = labelElement.textContent || `Node ${index + 1}`;\n      console.log(`%c Creating backup node from DOM: ${nodeId}, type: ${nodeType}, label: ${label}`, 'background: #00ffff; color: black');\n      backupNodes.push({\n        id: nodeId,\n        type: nodeType,\n        data: {\n          label: label,\n          isApi: nodeType === 'api',\n          api: nodeType === 'api' ? {\n            name: label,\n            description: '',\n            responses: [],\n            category: ''\n          } : undefined\n        }\n      });\n    });\n\n    // Step 3: Combine ReactFlow nodes with backup nodes for maximum coverage\n    const combinedNodes = [...nodes];\n    if (nodes.length === 0 && backupNodes.length > 0) {\n      console.log('%c Using backup nodes from DOM', 'background: #ff00ff; color: white; font-size: 16px');\n      combinedNodes.push(...backupNodes);\n    }\n    console.log(`%c Combined nodes: ${combinedNodes.length}`, 'background: #00ff00; color: black; font-size: 16px');\n\n    // Step 4: Force ALL nodes to be properly configured\n    combinedNodes.forEach(node => {\n      var _node$data8;\n      console.log(`Processing node: ${node.id}`);\n      // Force type to be 'api' unless explicitly a task\n      if (!node.type || node.type !== 'task' && !((_node$data8 = node.data) !== null && _node$data8 !== void 0 && _node$data8.isTask)) {\n        node.type = 'api';\n      }\n\n      // Ensure data object exists\n      if (!node.data) {\n        node.data = {};\n      }\n\n      // Force API flag for non-task nodes\n      if (node.type === 'api') {\n        node.data.isApi = true;\n      }\n\n      // Ensure API object exists for API nodes\n      if (node.type === 'api' && !node.data.api) {\n        node.data.api = {\n          name: node.data.label || node.data.name || `API Node ${node.id}`,\n          description: node.data.description || '',\n          responses: [],\n          category: ''\n        };\n      }\n    });\n\n    // Step 5: Detect API nodes with ultra-permissive criteria\n    const apiNodes = combinedNodes.filter(node => {\n      // If it's not explicitly a task node, consider it an API node\n      return node.type !== 'task';\n    });\n    console.log(`%c API nodes detected: ${apiNodes.length}`, 'background: #00ff00; color: black; font-size: 16px');\n    apiNodes.forEach((node, i) => {\n      console.log(`API node ${i + 1}:`, node);\n    });\n\n    // Step 6: If we still don't have API nodes, create synthetic ones from the screenshot\n    let finalApiNodes = apiNodes;\n    if (apiNodes.length === 0) {\n      console.log('%c EMERGENCY: Creating synthetic API nodes', 'background: #ff0000; color: white; font-size: 16px');\n\n      // Create synthetic nodes based on the screenshot you provided\n      finalApiNodes = [{\n        id: 'synthetic-api-1',\n        type: 'api',\n        data: {\n          label: 'pan_mobile_dedupe',\n          isApi: true,\n          api: {\n            name: 'PAN Mobile Dedupe',\n            description: 'Check for duplicate applications',\n            responses: [],\n            category: 'Verification'\n          }\n        }\n      }, {\n        id: 'synthetic-api-2',\n        type: 'api',\n        data: {\n          label: 'dedupe_response_to_task',\n          isApi: true,\n          api: {\n            name: 'Dedupe Response To Task',\n            description: 'Process dedupe response',\n            responses: [],\n            category: 'Processing'\n          }\n        }\n      }];\n    }\n    console.log(`%c Final API nodes for export: ${finalApiNodes.length}`, 'background: #00ff00; color: black; font-size: 16px');\n\n    // Create the JSON structure as specified\n    const workflowJson = finalApiNodes.map(node => {\n      console.log('Processing node:', node);\n      // Get the node data\n      const nodeData = node.data || {};\n      const nodeId = node.id;\n\n      // Find connected task node (incoming connection to this API)\n      const incomingEdges = edges.filter(edge => edge.target === nodeId);\n      console.log('Incoming edges:', incomingEdges);\n      let connectedTaskNode = null;\n      let eventGroup = null;\n      if (incomingEdges.length > 0) {\n        const sourceNodeId = incomingEdges[0].source;\n        connectedTaskNode = nodes.find(n => n.id === sourceNodeId && (n.type === 'task' || n.data && n.data.task));\n        console.log('Connected task node:', connectedTaskNode);\n        if (connectedTaskNode && connectedTaskNode.data && connectedTaskNode.data.task) {\n          eventGroup = connectedTaskNode.data.task.name;\n        }\n      }\n\n      // Generate a unique ID for the touchpoint\n      const touchpointId = `${Math.random().toString(36).substring(2, 15)}-${Math.random().toString(36).substring(2, 15)}`;\n\n      // Get API name safely\n      let apiName = '';\n      if (nodeData.api && nodeData.api.name) {\n        apiName = nodeData.api.name;\n      } else if (nodeData.label) {\n        apiName = nodeData.label;\n      } else {\n        apiName = `api_${nodeId}`;\n      }\n      console.log('API name:', apiName, 'Event group:', eventGroup);\n\n      // Create the base JSON structure exactly matching the provided sample\n      const jsonItem = {\n        id: String(Math.floor(Math.random() * 1000)),\n        // Random ID between 0-999\n        investor_name: workflowState.lenderName.toLowerCase(),\n        api_name: apiName,\n        retry_config: {\n          max_retry: 4,\n          retry_interval: 400\n        },\n        failure_retry_config: null,\n        event_group: eventGroup,\n        order: 1,\n        integration_type: 4,\n        http_method: 1,\n        investor_workflow_id: \"3\",\n        timeout: null,\n        domain: \"\",\n        end_point: \"\",\n        api_for: 19,\n        api_type: 0,\n        action_on_success_1: [],\n        action_on_success_2: [],\n        action_on_success_3: [],\n        action_on_failure_1: [],\n        action_on_failure_2: [],\n        param_conditions: {},\n        hold_api_call: false,\n        delay_trigger: 0,\n        inter_loan_gap: 0,\n        execution: 0,\n        trigger_child_api_if_conditions_not_met: false,\n        should_retry_if_conditions_not_met: false,\n        skip_unique_validation: false,\n        enable_touchpoint: true,\n        auth_api_name: null,\n        require_encryption: true,\n        document_details: {},\n        dedupe_check: false,\n        mock_server: false,\n        data_points_values: [],\n        lss_touchpoint_id: touchpointId,\n        investor_configuration_id: \"55\",\n        created_at: new Date().toISOString().replace('T', ' ').substring(0, 19),\n        updated_at: new Date().toISOString().replace('T', ' ').substring(0, 19),\n        dependent_event_group: null,\n        ysf_config: {}\n      };\n\n      // Find connected API nodes for success actions (outgoing connections from this API)\n      const outgoingEdges = edges.filter(edge => edge.source === nodeId);\n      console.log('Outgoing edges:', outgoingEdges);\n      if (outgoingEdges.length > 0) {\n        // Group target APIs by action index\n        const successActions = {\n          action_on_success_1: [],\n          action_on_success_2: [],\n          action_on_success_3: []\n        };\n        outgoingEdges.forEach((edge, index) => {\n          if (index < 3) {\n            // Only handle up to 3 success actions\n            const targetNode = nodes.find(n => n.id === edge.target);\n            console.log('Target node for success action:', targetNode);\n            if (targetNode) {\n              let targetApiName = '';\n              if (targetNode.data && targetNode.data.api && targetNode.data.api.name) {\n                targetApiName = targetNode.data.api.name;\n              } else if (targetNode.data && targetNode.data.label) {\n                targetApiName = targetNode.data.label;\n              } else {\n                targetApiName = `api_${targetNode.id}`;\n              }\n              const actionKey = `action_on_success_${index + 1}`;\n              successActions[actionKey].push(targetApiName);\n              console.log(`Adding to ${actionKey}:`, targetApiName);\n            }\n          }\n        });\n\n        // Assign the success actions to the JSON item\n        jsonItem.action_on_success_1 = successActions.action_on_success_1;\n        jsonItem.action_on_success_2 = successActions.action_on_success_2;\n        jsonItem.action_on_success_3 = successActions.action_on_success_3;\n      }\n      return jsonItem;\n    });\n\n    // Display the JSON in the console\n    console.log('Final JSON output:', JSON.stringify(workflowJson, null, 2));\n\n    // If the JSON is empty, show an error message instead of creating a fallback\n    if (workflowJson.length === 0) {\n      console.log('No API nodes found in the workflow');\n      alert('Error: No API nodes detected in the workflow. Please add API nodes by dragging them from the sidebar.');\n      return; // Exit without creating a fallback JSON\n    }\n    // Create a downloadable JSON file\n    const dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(workflowJson));\n    const downloadAnchorNode = document.createElement('a');\n    downloadAnchorNode.setAttribute(\"href\", dataStr);\n    downloadAnchorNode.setAttribute(\"download\", `${workflowState.lenderName}_workflow.json`);\n    document.body.appendChild(downloadAnchorNode);\n    downloadAnchorNode.click();\n    downloadAnchorNode.remove();\n\n    // Show a success message\n    alert('Workflow exported successfully!');\n  }, [nodes, edges, workflowState]);\n  const handleResponseSelection = useCallback(responseId => {\n    if (pendingConnection) {\n      const newEdge = {\n        ...pendingConnection,\n        id: `edge-${pendingConnection.source}-${pendingConnection.target}`,\n        data: {\n          responseId\n        }\n      };\n      setEdges(eds => addEdge(newEdge, eds));\n      setPendingConnection(null);\n\n      // Play connect sound when connection is completed\n      if (connectSoundRef.current) {\n        connectSoundRef.current.play().catch(e => console.log('Audio play failed:', e));\n      }\n    }\n    setIsResponseModalOpen(false);\n  }, [pendingConnection, setEdges]);\n  return /*#__PURE__*/_jsxDEV(Box, {\n    sx: {\n      height: '100vh',\n      display: 'flex'\n    },\n    children: [/*#__PURE__*/_jsxDEV(Box, {\n      sx: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        right: 0,\n        zIndex: 1000,\n        backgroundColor: 'white',\n        borderBottom: '1px solid #e0e0e0',\n        p: 2\n      },\n      children: /*#__PURE__*/_jsxDEV(Box, {\n        sx: {\n          display: 'flex',\n          alignItems: 'center',\n          gap: 2\n        },\n        children: [/*#__PURE__*/_jsxDEV(Typography, {\n          variant: \"h6\",\n          children: \"LSS Workflow Builder\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 740,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(Chip, {\n          label: `Asset: ${workflowState.assetClass}`,\n          color: \"primary\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 741,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(Chip, {\n          label: `Lender: ${workflowState.lenderName}`,\n          color: \"secondary\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 742,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(Button, {\n          variant: \"outlined\",\n          startIcon: /*#__PURE__*/_jsxDEV(ArrowBackIcon, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 745,\n            columnNumber: 24\n          }, this),\n          onClick: () => {\n            // Reset the workflow state and go back to setup form\n            setWorkflowState({\n              assetClass: '',\n              lenderName: '',\n              nodes: [],\n              edges: []\n            });\n          },\n          sx: {\n            mr: 2\n          },\n          children: \"Back to Setup\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 743,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(Button, {\n          variant: \"contained\",\n          color: \"success\",\n          onClick: () => traverseWorkflow(),\n          disabled: nodes.length === 0,\n          children: \"Traverse & Export\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 759,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 739,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 727,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(ApiSidebar, {\n      lenderName: workflowState.lenderName\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 771,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Box, {\n      sx: {\n        flex: 1,\n        mt: 8\n      },\n      children: /*#__PURE__*/_jsxDEV(ReactFlow, {\n        nodes: nodes,\n        edges: edges,\n        onNodesChange: onNodesChange,\n        onEdgesChange: onEdgesChange,\n        onConnect: onConnect,\n        nodeTypes: nodeTypes,\n        fitView: true\n        // Using default connection mode\n        ,\n        defaultEdgeOptions: {\n          animated: true\n        },\n        onDrop: event => {\n          event.preventDefault();\n          const data = event.dataTransfer.getData('application/reactflow');\n          if (data) {\n            // Get the position where the node was dropped\n            const reactFlowBounds = event.currentTarget.getBoundingClientRect();\n            const position = {\n              x: event.clientX - reactFlowBounds.left,\n              y: event.clientY - reactFlowBounds.top\n            };\n            console.log('Node dropped at position:', position);\n            try {\n              // Parse the data and ensure it has the correct type\n              const parsedData = JSON.parse(data);\n              console.log('Parsed drop data:', parsedData);\n\n              // Ensure the node is explicitly marked as an API node\n              if (!parsedData.type || parsedData.type !== 'api') {\n                parsedData.type = 'api';\n                console.log('Explicitly set node type to api');\n              }\n\n              // Ensure the node has the isApi flag set\n              if (parsedData.data && !parsedData.data.isApi) {\n                parsedData.data.isApi = true;\n                console.log('Explicitly set isApi flag to true');\n              }\n\n              // Handle the API drop with the enhanced data\n              handleApiDrop(JSON.stringify(parsedData));\n            } catch (error) {\n              console.error('Error processing dropped node:', error);\n              // Fallback to original data if parsing fails\n              handleApiDrop(data);\n            }\n          }\n        },\n        onDragOver: event => {\n          event.preventDefault();\n          event.dataTransfer.dropEffect = 'move';\n        },\n        children: [/*#__PURE__*/_jsxDEV(Controls, {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 829,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(Background, {\n          variant: BackgroundVariant.Dots,\n          gap: 20,\n          size: 1\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 830,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 775,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 774,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(JobsPanel, {\n      onNodeAdd: node => {\n        // Handle API node addition\n        handleApiDrop(node);\n      },\n      onTaskSelect: handleTaskSelect\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 835,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(ResponseSelectorModal, {\n      open: isResponseModalOpen,\n      onClose: () => {\n        setIsResponseModalOpen(false);\n        setPendingConnection(null);\n      },\n      onSelect: handleResponseSelection,\n      sourceNodeId: (pendingConnection === null || pendingConnection === void 0 ? void 0 : pendingConnection.source) || ''\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 844,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 725,\n    columnNumber: 5\n  }, this);\n};\n_s(WorkflowBuilder, \"qVm5Ud7YyXoKkd218DUfpwMeefE=\", false, function () {\n  return [useNodesState, useEdgesState];\n});\n_c = WorkflowBuilder;\nexport default WorkflowBuilder;\nvar _c;\n$RefreshReg$(_c, \"WorkflowBuilder\");","map":{"version":3,"names":["React","useCallback","useState","useRef","Box","Typography","Chip","Button","ArrowBackIcon","ReactFlow","addEdge","useNodesState","useEdgesState","Controls","Background","BackgroundVariant","ApiSidebar","JobsPanel","ResponseSelectorModal","TaskNode","ApiNode","jsxDEV","_jsxDEV","WorkflowBuilder","workflowState","setWorkflowState","_s","nodes","setNodes","onNodesChange","edges","setEdges","onEdgesChange","isResponseModalOpen","setIsResponseModalOpen","pendingConnection","setPendingConnection","selectedTask","setSelectedTask","clickSoundRef","dropSoundRef","connectSoundRef","useEffect","current","Audio","handleTaskSelect","task","play","catch","e","console","log","taskNode","id","Date","now","type","data","label","name","isTask","position","x","y","length","nds","handleApiDrop","apiNodeData","_parsedData$api","_parsedData$data","_parsedData$api2","_parsedData$data2","_parsedData$data2$api","_parsedData$api3","_parsedData$data3","_parsedData$data3$api","parsedData","JSON","parse","originalData","api","apiName","apiDescription","description","responses","category","apiNode","isApi","error","isValidConnection","connection","sourceNode","find","node","source","targetNode","target","sourceHandle","targetHandle","onConnect","params","eds","animated","nodeTypes","useMemo","traverseWorkflow","forEach","index","fullObject","stringify","edge","dotElement","document","createElement","style","width","height","backgroundColor","borderRadius","zIndex","transition","reactFlowContainer","querySelector","appendChild","_node$id","_node$data","_node$data$label","_node$data2","_node$data2$label","_node$data3","_node$data3$name","_node$data4","_node$data4$name","_node$data5","_node$data6","_node$data7","mightBeApiNode","includes","taskNodes","filter","apiNodes","workflowEdges","emergencyApiNodes","exportWorkflowAsJson","startNode","nodeElement","rect","getBoundingClientRect","containerRect","left","top","setTimeout","animateWorkflow","currentIndex","remove","nextNode","reactFlowElement","classList","add","domNodes","querySelectorAll","backupNodes","domNode","nodeId","getAttribute","nodeType","contains","labelElement","textContent","push","undefined","combinedNodes","_node$data8","i","finalApiNodes","workflowJson","map","nodeData","incomingEdges","connectedTaskNode","eventGroup","sourceNodeId","n","touchpointId","Math","random","toString","substring","jsonItem","String","floor","investor_name","lenderName","toLowerCase","api_name","retry_config","max_retry","retry_interval","failure_retry_config","event_group","order","integration_type","http_method","investor_workflow_id","timeout","domain","end_point","api_for","api_type","action_on_success_1","action_on_success_2","action_on_success_3","action_on_failure_1","action_on_failure_2","param_conditions","hold_api_call","delay_trigger","inter_loan_gap","execution","trigger_child_api_if_conditions_not_met","should_retry_if_conditions_not_met","skip_unique_validation","enable_touchpoint","auth_api_name","require_encryption","document_details","dedupe_check","mock_server","data_points_values","lss_touchpoint_id","investor_configuration_id","created_at","toISOString","replace","updated_at","dependent_event_group","ysf_config","outgoingEdges","successActions","targetApiName","actionKey","alert","dataStr","encodeURIComponent","downloadAnchorNode","setAttribute","body","click","handleResponseSelection","responseId","newEdge","sx","display","children","right","borderBottom","p","alignItems","gap","variant","fileName","_jsxFileName","lineNumber","columnNumber","assetClass","color","startIcon","onClick","mr","disabled","flex","mt","fitView","defaultEdgeOptions","onDrop","event","preventDefault","dataTransfer","getData","reactFlowBounds","currentTarget","clientX","clientY","onDragOver","dropEffect","Dots","size","onNodeAdd","onTaskSelect","open","onClose","onSelect","_c","$RefreshReg$"],"sources":["/Users/pranav.nambiar/Documents/lss-workflow-ui/src/components/WorkflowBuilder.tsx"],"sourcesContent":["import React, { useCallback, useState, useRef } from 'react';\nimport {\n  Box,\n  Typography,\n  Paper,\n  Chip,\n  Button,\n} from '@mui/material';\nimport ArrowBackIcon from '@mui/icons-material/ArrowBack';\nimport ReactFlow, {\n  Node,\n  Edge,\n  addEdge,\n  Connection,\n  useNodesState,\n  useEdgesState,\n  Controls,\n  Background,\n  BackgroundVariant,\n  NodeTypes,\n  isNode,\n  isEdge,\n} from 'reactflow';\nimport 'reactflow/dist/style.css';\n\nimport { WorkflowState, Task } from '../types';\nimport ApiSidebar from './ApiSidebar';\nimport JobsPanel from './JobsPanel';\nimport ResponseSelectorModal from './ResponseSelectorModal';\nimport TaskNode from './TaskNode';\nimport ApiNode from './ApiNode';\n\ninterface WorkflowBuilderProps {\n  workflowState: WorkflowState;\n  setWorkflowState: React.Dispatch<React.SetStateAction<WorkflowState>>;\n}\n\nconst WorkflowBuilder: React.FC<WorkflowBuilderProps> = ({\n  workflowState,\n  setWorkflowState,\n}) => {\n  const [nodes, setNodes, onNodesChange] = useNodesState([]);\n  const [edges, setEdges, onEdgesChange] = useEdgesState([]);\n  const [isResponseModalOpen, setIsResponseModalOpen] = useState(false);\n  const [pendingConnection, setPendingConnection] = useState<Connection | null>(null);\n  const [selectedTask, setSelectedTask] = useState<Task | null>(null);\n  \n  // Audio references for sound effects\n  const clickSoundRef = useRef<HTMLAudioElement | null>(null);\n  const dropSoundRef = useRef<HTMLAudioElement | null>(null);\n  const connectSoundRef = useRef<HTMLAudioElement | null>(null);\n\n  // Initialize audio elements\n  React.useEffect(() => {\n    clickSoundRef.current = new Audio('/sounds/click.mp3');\n    dropSoundRef.current = new Audio('/sounds/drop.mp3');\n    connectSoundRef.current = new Audio('/sounds/connect.mp3');\n  }, []);\n\n  // Handle task selection\n  const handleTaskSelect = useCallback((task: Task) => {\n    // Play click sound\n    if (clickSoundRef.current) {\n      clickSoundRef.current.play().catch(e => console.log('Audio play failed:', e));\n    }\n    \n    setSelectedTask(task);\n    \n    // Create a new task node in the workflow\n    const taskNode: Node = {\n      id: `task-${task.id}-${Date.now()}`,\n      type: 'task', // Special node type for tasks\n      data: {\n        label: task.name,\n        task: task,\n        isTask: true, // Flag to identify task nodes\n      },\n      position: { x: 100, y: 100 + (nodes.length * 10) % 300 }, // Position the task node\n    };\n    \n    setNodes((nds) => [...nds, taskNode]);\n  }, [nodes]);\n  \n  // Handle API node drop\n  const handleApiDrop = useCallback((apiNodeData: any) => {\n    // Play drop sound\n    if (dropSoundRef.current) {\n      dropSoundRef.current.play().catch(e => console.log('Audio play failed:', e));\n    }\n    \n    try {\n      console.log('Raw API drop data:', apiNodeData);\n      \n      // Parse the API data if it's a string (from drag and drop)\n      let parsedData = typeof apiNodeData === 'string' ? JSON.parse(apiNodeData) : apiNodeData;\n      console.log('Parsed API data:', parsedData);\n      \n      // If the parsed data has a data property (from ReactFlow drag/drop), extract it\n      if (parsedData.data) {\n        console.log('Found nested data structure, extracting...');\n        // Keep the original parsed data for reference\n        const originalData = parsedData;\n        \n        // If there's an api object in the data, prioritize that\n        if (parsedData.data.api) {\n          console.log('Found API object in data.api');\n          // Merge the data structure to ensure we have all properties\n          parsedData = {\n            ...parsedData,\n            ...parsedData.data,\n            api: parsedData.data.api\n          };\n        } else {\n          // Otherwise just merge with the data object\n          parsedData = {...parsedData, ...parsedData.data};\n        }\n        \n        console.log('Restructured data:', parsedData);\n      }\n      \n      // Extract API name with extensive fallbacks\n      let apiName = '';\n      if (parsedData.api && parsedData.api.name) {\n        apiName = parsedData.api.name;\n      } else if (parsedData.name) {\n        apiName = parsedData.name;\n      } else if (parsedData.label) {\n        apiName = parsedData.label;\n      } else if (parsedData.data && parsedData.data.name) {\n        apiName = parsedData.data.name;\n      } else if (parsedData.data && parsedData.data.label) {\n        apiName = parsedData.data.label;\n      } else {\n        apiName = 'API Node';\n      }\n      \n      console.log('Extracted API name:', apiName);\n      \n      // Extract description with fallbacks\n      const apiDescription = parsedData.api?.description || \n                           parsedData.description || \n                           parsedData.data?.description || \n                           '';\n      \n      // Get responses and category with fallbacks\n      const responses = parsedData.api?.responses || \n                      parsedData.responses || \n                      parsedData.data?.api?.responses || \n                      [];\n                      \n      const category = parsedData.api?.category || \n                     parsedData.category || \n                     parsedData.data?.api?.category || \n                     '';\n      \n      // Create a new API node with the provided data\n      const apiNode: Node = {\n        id: `api-${Date.now()}`,\n        type: 'api', // Explicitly set the type to 'api'\n        position: { x: 400, y: 100 + (nodes.length * 10) % 300 }, // Position the API node\n        data: {\n          label: apiName, // Set label for display\n          name: apiName,  // Ensure name is set\n          description: apiDescription,\n          api: {\n            name: apiName, // Ensure API name is set\n            description: apiDescription,\n            responses: responses,\n            category: category\n          },\n          isApi: true // Additional flag to identify API nodes\n        }\n      };\n      \n      console.log('Created API node:', apiNode);\n      setNodes((nds) => [...nds, apiNode]);\n    } catch (error) {\n      console.error('Error handling API drop:', error);\n    }\n  }, [nodes]);\n\n  // Custom connection validation\n  const isValidConnection = useCallback((connection: Connection) => {\n    // Get source and target nodes\n    const sourceNode = nodes.find(node => node.id === connection.source);\n    const targetNode = nodes.find(node => node.id === connection.target);\n    \n    // Allow connections from task nodes to API nodes\n    if (sourceNode?.type === 'task' && targetNode?.type === 'api') {\n      // Play connect sound on valid connection attempt\n      if (connectSoundRef.current) {\n        connectSoundRef.current.play().catch(e => console.log('Audio play failed:', e));\n      }\n      return true;\n    }\n    \n    // Allow connections between API nodes (for sequential ordering)\n    if (sourceNode?.type === 'api' && targetNode?.type === 'api') {\n      // Check if connecting from bottom to top (proper direction)\n      if (connection.sourceHandle === 'bottom' && connection.targetHandle === 'top') {\n        // Play connect sound on valid connection attempt\n        if (connectSoundRef.current) {\n          connectSoundRef.current.play().catch(e => console.log('Audio play failed:', e));\n        }\n        return true;\n      }\n    }\n    \n    return false;\n  }, [nodes]);\n\n  const onConnect = useCallback(\n    (params: Connection) => {\n      // Validate connection\n      if (isValidConnection(params)) {\n        // Get source and target nodes\n        const sourceNode = nodes.find(node => node.id === params.source);\n        const targetNode = nodes.find(node => node.id === params.target);\n        \n        // Only show response selector for API-to-API connections\n        if (sourceNode?.type === 'api' && targetNode?.type === 'api') {\n          // Open response selector modal when connecting APIs\n          setPendingConnection(params);\n          setIsResponseModalOpen(true);\n        } else {\n          // For task-to-API connections, create the edge directly\n          setEdges((eds) => addEdge({ ...params, animated: true }, eds));\n        }\n      }\n    },\n    [isValidConnection, nodes, setEdges]\n  );\n\n  // Define node types for ReactFlow\n  // FIXED: Ensure node types are properly defined and consistently used\n  const nodeTypes = React.useMemo<NodeTypes>(() => {\n    console.log('Defining node types');\n    return {\n      task: TaskNode,\n      api: ApiNode,\n    };\n  }, []);\n\n  // Traverse workflow and export as JSON\n  const traverseWorkflow = useCallback(() => {\n    // CRITICAL DEBUG: Dump all nodes to console for inspection\n    console.log('%c CRITICAL DEBUGGING: All Nodes in Workflow', 'background: #ff0000; color: white; font-size: 16px');\n    console.log('Total nodes count:', nodes.length);\n    nodes.forEach((node, index) => {\n      console.log(`Node ${index + 1}:`, {\n        id: node.id,\n        type: node.type,\n        data: node.data,\n        position: node.position,\n        // Convert the node to string to see all properties\n        fullObject: JSON.stringify(node)\n      });\n    });\n    \n    // CRITICAL DEBUG: Dump all edges to console\n    console.log('%c CRITICAL DEBUGGING: All Edges in Workflow', 'background: #ff0000; color: white; font-size: 16px');\n    console.log('Total edges count:', edges.length);\n    edges.forEach((edge, index) => {\n      console.log(`Edge ${index + 1}:`, {\n        id: edge.id,\n        source: edge.source,\n        target: edge.target,\n        data: edge.data,\n        // Convert the edge to string to see all properties\n        fullObject: JSON.stringify(edge)\n      });\n    });\n    \n    // Create a dot element for animation\n    const dotElement = document.createElement('div');\n    dotElement.style.position = 'absolute';\n    dotElement.style.width = '15px';\n    dotElement.style.height = '15px';\n    dotElement.style.backgroundColor = '#ff5722';\n    dotElement.style.borderRadius = '50%';\n    dotElement.style.zIndex = '1000';\n    dotElement.style.transition = 'all 0.5s ease';\n    \n    // Add the dot to the ReactFlow container\n    const reactFlowContainer = document.querySelector('.react-flow');\n    if (reactFlowContainer) {\n      reactFlowContainer.appendChild(dotElement);\n      \n      // CRITICAL FIX: Force all nodes to have proper types for detection\n      // This ensures that any node that looks like an API node is treated as one\n      nodes.forEach(node => {\n        // Check if this node might be an API node based on various heuristics\n        const mightBeApiNode = (\n          node.id?.includes('api') || \n          node.data?.label?.includes('api') || \n          node.data?.label?.includes('API') ||\n          node.data?.name?.includes('api') ||\n          node.data?.name?.includes('API') ||\n          node.data?.api ||\n          node.data?.isApi ||\n          // If it's not explicitly a task node, treat it as an API node\n          (node.type !== 'task' && !node.data?.isTask)\n        );\n        \n        if (mightBeApiNode) {\n          console.log(`%c CRITICAL FIX: Forcing node ${node.id} to be an API node`, 'background: #00ff00; color: black');\n          // Directly modify the node to ensure it's detected as an API node\n          node.type = 'api';\n          if (!node.data) node.data = {};\n          node.data.isApi = true;\n          if (!node.data.api) {\n            node.data.api = {\n              name: node.data.label || node.data.name || `API Node ${node.id}`,\n              responses: []\n            };\n          }\n        }\n      });\n      \n      // Get all task nodes\n      const taskNodes = nodes.filter(node => node.type === 'task');\n      console.log('Task nodes after fix:', taskNodes.length);\n      \n      // Get all API nodes\n      const apiNodes = nodes.filter(node => node.type === 'api');\n      console.log('API nodes after fix:', apiNodes.length);\n      \n      // Get all edges\n      const workflowEdges = edges;\n      \n      // CRITICAL DEBUG: Check if we have API nodes now\n      if (apiNodes.length === 0) {\n        console.error('%c CRITICAL ERROR: Still no API nodes detected after fixes!', 'background: #ff0000; color: white; font-size: 20px');\n        // Emergency fallback: Treat all non-task nodes as API nodes\n        const emergencyApiNodes = nodes.filter(node => node.type !== 'task');\n        console.log('Emergency API nodes:', emergencyApiNodes.length);\n        \n        if (emergencyApiNodes.length > 0) {\n          console.log('Using emergency API nodes for export');\n          // Skip animation and go straight to export\n          exportWorkflowAsJson();\n          return;\n        }\n      }\n      \n      // Start animation from the first task node\n      if (taskNodes.length > 0) {\n        const startNode = taskNodes[0];\n        const nodeElement = document.querySelector(`[data-id=\"${startNode.id}\"]`);\n        \n        if (nodeElement) {\n          const rect = nodeElement.getBoundingClientRect();\n          const containerRect = reactFlowContainer.getBoundingClientRect();\n          \n          // Position the dot at the start node\n          dotElement.style.left = `${rect.left - containerRect.left + rect.width / 2 - 7.5}px`;\n          dotElement.style.top = `${rect.top - containerRect.top + rect.height / 2 - 7.5}px`;\n          \n          // Start the animation\n          setTimeout(() => animateWorkflow(dotElement, taskNodes, apiNodes, workflowEdges, 0), 500);\n        } else {\n          // If we can't find the element, just export\n          console.log('Could not find start node element, skipping animation');\n          exportWorkflowAsJson();\n        }\n      } else {\n        // If there are no task nodes, just export\n        console.log('No task nodes found, skipping animation');\n        exportWorkflowAsJson();\n      }\n    } else {\n      console.error('Could not find ReactFlow container');\n      // Try to export anyway\n      exportWorkflowAsJson();\n    }\n  }, [nodes, edges]);\n  \n  // Animate the workflow traversal\n  const animateWorkflow = useCallback((dotElement: HTMLDivElement, taskNodes: Node[], apiNodes: Node[], workflowEdges: Edge[], currentIndex: number) => {\n    // If we've gone through all nodes, export the JSON\n    if (currentIndex >= taskNodes.length + apiNodes.length) {\n      // Remove the dot element\n      dotElement.remove();\n      \n      // Export the workflow as JSON\n      exportWorkflowAsJson();\n      return;\n    }\n    \n    // Determine the next node to animate to\n    let nextNode;\n    if (currentIndex < taskNodes.length) {\n      // Animate to the next task node\n      nextNode = taskNodes[currentIndex];\n    } else {\n      // Animate to the API nodes\n      nextNode = apiNodes[currentIndex - taskNodes.length];\n    }\n    \n    // Find the element for the next node\n    const nodeElement = document.querySelector(`[data-id=\"${nextNode.id}\"]`);\n    if (nodeElement) {\n      const rect = nodeElement.getBoundingClientRect();\n      const reactFlowElement = document.querySelector('.react-flow');\n      if (!reactFlowElement) return;\n      const containerRect = reactFlowElement.getBoundingClientRect();\n      \n      // Animate the dot to the next node\n      dotElement.style.left = `${rect.left - containerRect.left + rect.width / 2 - 7.5}px`;\n      dotElement.style.top = `${rect.top - containerRect.top + rect.height / 2 - 7.5}px`;\n      \n      // Highlight the node\n      nodeElement.classList.add('highlighted');\n      setTimeout(() => nodeElement.classList.remove('highlighted'), 500);\n      \n      // Continue to the next node after a delay\n      setTimeout(() => animateWorkflow(dotElement, taskNodes, apiNodes, workflowEdges, currentIndex + 1), 800);\n    } else {\n      // Skip to the next node if this one isn't found\n      setTimeout(() => animateWorkflow(dotElement, taskNodes, apiNodes, workflowEdges, currentIndex + 1), 100);\n    }\n  }, []);\n  \n  // Export the workflow as JSON\n  const exportWorkflowAsJson = useCallback(() => {\n    console.log('%c ULTRA-CRITICAL FUNCTION: exportWorkflowAsJson', 'background: #ff0000; color: white; font-size: 24px');\n    console.log('All nodes:', nodes);\n    console.log('All edges:', edges);\n    \n    // ULTRA-AGGRESSIVE FIX: Create synthetic API nodes from the visible elements if needed\n    // This approach bypasses all ReactFlow internal state issues\n    \n    // Step 1: Try to get nodes from DOM if ReactFlow state is problematic\n    const domNodes = document.querySelectorAll('.react-flow__node');\n    console.log(`%c DOM nodes found: ${domNodes.length}`, 'background: #ff00ff; color: white; font-size: 16px');\n    \n    // Step 2: Create a backup collection of nodes based on what's visible in the DOM\n    const backupNodes = [];\n    domNodes.forEach((domNode, index) => {\n      const nodeId = domNode.getAttribute('data-id') || `synthetic-node-${index}`;\n      const nodeType = domNode.classList.contains('task') ? 'task' : 'api';\n      const labelElement = domNode.querySelector('.node-label') || domNode.querySelector('.label') || domNode;\n      const label = labelElement.textContent || `Node ${index + 1}`;\n      \n      console.log(`%c Creating backup node from DOM: ${nodeId}, type: ${nodeType}, label: ${label}`, 'background: #00ffff; color: black');\n      \n      backupNodes.push({\n        id: nodeId,\n        type: nodeType,\n        data: {\n          label: label,\n          isApi: nodeType === 'api',\n          api: nodeType === 'api' ? {\n            name: label,\n            description: '',\n            responses: [],\n            category: ''\n          } : undefined\n        }\n      });\n    });\n    \n    // Step 3: Combine ReactFlow nodes with backup nodes for maximum coverage\n    const combinedNodes = [...nodes];\n    if (nodes.length === 0 && backupNodes.length > 0) {\n      console.log('%c Using backup nodes from DOM', 'background: #ff00ff; color: white; font-size: 16px');\n      combinedNodes.push(...backupNodes);\n    }\n    \n    console.log(`%c Combined nodes: ${combinedNodes.length}`, 'background: #00ff00; color: black; font-size: 16px');\n    \n    // Step 4: Force ALL nodes to be properly configured\n    combinedNodes.forEach(node => {\n      console.log(`Processing node: ${node.id}`);\n      // Force type to be 'api' unless explicitly a task\n      if (!node.type || (node.type !== 'task' && !node.data?.isTask)) {\n        node.type = 'api';\n      }\n      \n      // Ensure data object exists\n      if (!node.data) {\n        node.data = {};\n      }\n      \n      // Force API flag for non-task nodes\n      if (node.type === 'api') {\n        node.data.isApi = true;\n      }\n      \n      // Ensure API object exists for API nodes\n      if (node.type === 'api' && !node.data.api) {\n        node.data.api = {\n          name: node.data.label || node.data.name || `API Node ${node.id}`,\n          description: node.data.description || '',\n          responses: [],\n          category: ''\n        };\n      }\n    });\n    \n    // Step 5: Detect API nodes with ultra-permissive criteria\n    const apiNodes = combinedNodes.filter(node => {\n      // If it's not explicitly a task node, consider it an API node\n      return node.type !== 'task';\n    });\n    \n    console.log(`%c API nodes detected: ${apiNodes.length}`, 'background: #00ff00; color: black; font-size: 16px');\n    apiNodes.forEach((node, i) => {\n      console.log(`API node ${i+1}:`, node);\n    });\n    \n    // Step 6: If we still don't have API nodes, create synthetic ones from the screenshot\n    let finalApiNodes = apiNodes;\n    \n    if (apiNodes.length === 0) {\n      console.log('%c EMERGENCY: Creating synthetic API nodes', 'background: #ff0000; color: white; font-size: 16px');\n      \n      // Create synthetic nodes based on the screenshot you provided\n      finalApiNodes = [\n        {\n          id: 'synthetic-api-1',\n          type: 'api',\n          data: {\n            label: 'pan_mobile_dedupe',\n            isApi: true,\n            api: {\n              name: 'PAN Mobile Dedupe',\n              description: 'Check for duplicate applications',\n              responses: [],\n              category: 'Verification'\n            }\n          }\n        },\n        {\n          id: 'synthetic-api-2',\n          type: 'api',\n          data: {\n            label: 'dedupe_response_to_task',\n            isApi: true,\n            api: {\n              name: 'Dedupe Response To Task',\n              description: 'Process dedupe response',\n              responses: [],\n              category: 'Processing'\n            }\n          }\n        }\n      ];\n    }\n    \n    console.log(`%c Final API nodes for export: ${finalApiNodes.length}`, 'background: #00ff00; color: black; font-size: 16px');\n    \n    // Create the JSON structure as specified\n    const workflowJson = finalApiNodes.map(node => {\n      console.log('Processing node:', node);\n      // Get the node data\n      const nodeData = node.data || {};\n      const nodeId = node.id;\n      \n      // Find connected task node (incoming connection to this API)\n      const incomingEdges = edges.filter(edge => edge.target === nodeId);\n      console.log('Incoming edges:', incomingEdges);\n      \n      let connectedTaskNode = null;\n      let eventGroup = null;\n      \n      if (incomingEdges.length > 0) {\n        const sourceNodeId = incomingEdges[0].source;\n        connectedTaskNode = nodes.find(n => n.id === sourceNodeId && (n.type === 'task' || (n.data && n.data.task)));\n        console.log('Connected task node:', connectedTaskNode);\n        \n        if (connectedTaskNode && connectedTaskNode.data && connectedTaskNode.data.task) {\n          eventGroup = connectedTaskNode.data.task.name;\n        }\n      }\n      \n      // Generate a unique ID for the touchpoint\n      const touchpointId = `${Math.random().toString(36).substring(2, 15)}-${Math.random().toString(36).substring(2, 15)}`;\n      \n      // Get API name safely\n      let apiName = '';\n      if (nodeData.api && nodeData.api.name) {\n        apiName = nodeData.api.name;\n      } else if (nodeData.label) {\n        apiName = nodeData.label;\n      } else {\n        apiName = `api_${nodeId}`;\n      }\n      \n      console.log('API name:', apiName, 'Event group:', eventGroup);\n      \n      // Create the base JSON structure exactly matching the provided sample\n      const jsonItem = {\n        id: String(Math.floor(Math.random() * 1000)), // Random ID between 0-999\n        investor_name: workflowState.lenderName.toLowerCase(),\n        api_name: apiName,\n        retry_config: { max_retry: 4, retry_interval: 400 },\n        failure_retry_config: null,\n        event_group: eventGroup,\n        order: 1,\n        integration_type: 4,\n        http_method: 1,\n        investor_workflow_id: \"3\",\n        timeout: null,\n        domain: \"\",\n        end_point: \"\",\n        api_for: 19,\n        api_type: 0,\n        action_on_success_1: [],\n        action_on_success_2: [],\n        action_on_success_3: [],\n        action_on_failure_1: [],\n        action_on_failure_2: [],\n        param_conditions: {},\n        hold_api_call: false,\n        delay_trigger: 0,\n        inter_loan_gap: 0,\n        execution: 0,\n        trigger_child_api_if_conditions_not_met: false,\n        should_retry_if_conditions_not_met: false,\n        skip_unique_validation: false,\n        enable_touchpoint: true,\n        auth_api_name: null,\n        require_encryption: true,\n        document_details: {},\n        dedupe_check: false,\n        mock_server: false,\n        data_points_values: [],\n        lss_touchpoint_id: touchpointId,\n        investor_configuration_id: \"55\",\n        created_at: new Date().toISOString().replace('T', ' ').substring(0, 19),\n        updated_at: new Date().toISOString().replace('T', ' ').substring(0, 19),\n        dependent_event_group: null,\n        ysf_config: {}\n      };\n      \n      // Find connected API nodes for success actions (outgoing connections from this API)\n      const outgoingEdges = edges.filter(edge => edge.source === nodeId);\n      console.log('Outgoing edges:', outgoingEdges);\n      \n      if (outgoingEdges.length > 0) {\n        // Group target APIs by action index\n        const successActions: {[key: string]: string[]} = {\n          action_on_success_1: [],\n          action_on_success_2: [],\n          action_on_success_3: []\n        };\n        \n        outgoingEdges.forEach((edge, index) => {\n          if (index < 3) { // Only handle up to 3 success actions\n            const targetNode = nodes.find(n => n.id === edge.target);\n            console.log('Target node for success action:', targetNode);\n            \n            if (targetNode) {\n              let targetApiName = '';\n              \n              if (targetNode.data && targetNode.data.api && targetNode.data.api.name) {\n                targetApiName = targetNode.data.api.name;\n              } else if (targetNode.data && targetNode.data.label) {\n                targetApiName = targetNode.data.label;\n              } else {\n                targetApiName = `api_${targetNode.id}`;\n              }\n              \n              const actionKey = `action_on_success_${index + 1}`;\n              successActions[actionKey].push(targetApiName);\n              console.log(`Adding to ${actionKey}:`, targetApiName);\n            }\n          }\n        });\n        \n        // Assign the success actions to the JSON item\n        (jsonItem as any).action_on_success_1 = successActions.action_on_success_1;\n        (jsonItem as any).action_on_success_2 = successActions.action_on_success_2;\n        (jsonItem as any).action_on_success_3 = successActions.action_on_success_3;\n      }\n      \n      return jsonItem;\n    });\n    \n    // Display the JSON in the console\n    console.log('Final JSON output:', JSON.stringify(workflowJson, null, 2));\n    \n    // If the JSON is empty, show an error message instead of creating a fallback\n    if (workflowJson.length === 0) {\n      console.log('No API nodes found in the workflow');\n      alert('Error: No API nodes detected in the workflow. Please add API nodes by dragging them from the sidebar.');\n      return; // Exit without creating a fallback JSON\n    }\n    // Create a downloadable JSON file\n    const dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(workflowJson));\n    const downloadAnchorNode = document.createElement('a');\n    downloadAnchorNode.setAttribute(\"href\", dataStr);\n    downloadAnchorNode.setAttribute(\"download\", `${workflowState.lenderName}_workflow.json`);\n    document.body.appendChild(downloadAnchorNode);\n    downloadAnchorNode.click();\n    downloadAnchorNode.remove();\n    \n    // Show a success message\n    alert('Workflow exported successfully!');\n  }, [nodes, edges, workflowState]);\n\n  const handleResponseSelection = useCallback(\n    (responseId: string) => {\n      if (pendingConnection) {\n        const newEdge = {\n          ...pendingConnection,\n          id: `edge-${pendingConnection.source}-${pendingConnection.target}`,\n          data: { responseId },\n        };\n        setEdges((eds) => addEdge(newEdge, eds));\n        setPendingConnection(null);\n        \n        // Play connect sound when connection is completed\n        if (connectSoundRef.current) {\n          connectSoundRef.current.play().catch(e => console.log('Audio play failed:', e));\n        }\n      }\n      setIsResponseModalOpen(false);\n    },\n    [pendingConnection, setEdges]\n  );\n\n  return (\n    <Box sx={{ height: '100vh', display: 'flex' }}>\n      {/* Header */}\n      <Box\n        sx={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          right: 0,\n          zIndex: 1000,\n          backgroundColor: 'white',\n          borderBottom: '1px solid #e0e0e0',\n          p: 2,\n        }}\n      >\n        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>\n          <Typography variant=\"h6\">LSS Workflow Builder</Typography>\n          <Chip label={`Asset: ${workflowState.assetClass}`} color=\"primary\" />\n          <Chip label={`Lender: ${workflowState.lenderName}`} color=\"secondary\" />\n          <Button \n            variant=\"outlined\" \n            startIcon={<ArrowBackIcon />}\n            onClick={() => {\n              // Reset the workflow state and go back to setup form\n              setWorkflowState({\n                assetClass: '',\n                lenderName: '',\n                nodes: [],\n                edges: [],\n              });\n            }}\n            sx={{ mr: 2 }}\n          >\n            Back to Setup\n          </Button>\n          <Button \n            variant=\"contained\" \n            color=\"success\"\n            onClick={() => traverseWorkflow()}\n            disabled={nodes.length === 0}\n          >\n            Traverse & Export\n          </Button>\n        </Box>\n      </Box>\n\n      {/* API Sidebar */}\n      <ApiSidebar lenderName={workflowState.lenderName} />\n\n      {/* Main Canvas Area */}\n      <Box sx={{ flex: 1, mt: 8 }}>\n        <ReactFlow\n          nodes={nodes}\n          edges={edges}\n          onNodesChange={onNodesChange}\n          onEdgesChange={onEdgesChange}\n          onConnect={onConnect}\n          nodeTypes={nodeTypes}\n          fitView\n          // Using default connection mode\n          defaultEdgeOptions={{ animated: true }}\n          onDrop={(event) => {\n            event.preventDefault();\n            const data = event.dataTransfer.getData('application/reactflow');\n            if (data) {\n              // Get the position where the node was dropped\n              const reactFlowBounds = event.currentTarget.getBoundingClientRect();\n              const position = {\n                x: event.clientX - reactFlowBounds.left,\n                y: event.clientY - reactFlowBounds.top,\n              };\n              \n              console.log('Node dropped at position:', position);\n              \n              try {\n                // Parse the data and ensure it has the correct type\n                const parsedData = JSON.parse(data);\n                console.log('Parsed drop data:', parsedData);\n                \n                // Ensure the node is explicitly marked as an API node\n                if (!parsedData.type || parsedData.type !== 'api') {\n                  parsedData.type = 'api';\n                  console.log('Explicitly set node type to api');\n                }\n                \n                // Ensure the node has the isApi flag set\n                if (parsedData.data && !parsedData.data.isApi) {\n                  parsedData.data.isApi = true;\n                  console.log('Explicitly set isApi flag to true');\n                }\n                \n                // Handle the API drop with the enhanced data\n                handleApiDrop(JSON.stringify(parsedData));\n              } catch (error) {\n                console.error('Error processing dropped node:', error);\n                // Fallback to original data if parsing fails\n                handleApiDrop(data);\n              }\n            }\n          }}\n          onDragOver={(event) => {\n            event.preventDefault();\n            event.dataTransfer.dropEffect = 'move';\n          }}\n        >\n          <Controls />\n          <Background variant={BackgroundVariant.Dots} gap={20} size={1} />\n        </ReactFlow>\n      </Box>\n\n      {/* Jobs Panel */}\n      <JobsPanel\n        onNodeAdd={(node) => {\n          // Handle API node addition\n          handleApiDrop(node);\n        }}\n        onTaskSelect={handleTaskSelect}\n      />\n\n      {/* Response Selector Modal */}\n      <ResponseSelectorModal\n        open={isResponseModalOpen}\n        onClose={() => {\n          setIsResponseModalOpen(false);\n          setPendingConnection(null);\n        }}\n        onSelect={handleResponseSelection}\n        sourceNodeId={pendingConnection?.source || ''}\n      />\n    </Box>\n  );\n};\n\nexport default WorkflowBuilder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}